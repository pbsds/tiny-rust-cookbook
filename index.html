<p>This document is compiled to teach you all the necessary basics needed to get the assignments done using <strong>Rust</strong>. It is very lean, and attempts to avoid the vast majority of details unrelated to completing the assignment.</p>
<p>We’re using Rust instead of C++ for a bunch of reasons, primarily:</p>
<ul class="incremental">
<li>Better tooling in general</li>
<li>Easier compilation across platforms <em>(although mac is not supported for the coursework)</em></li>
<li>Many of the mistakes students traditionally have been making in this course are a lot harder to make in Rust</li>
</ul>
<p>You will not have to learn a lot of Rust to be able to complete the course. The majority of the challenge will be learning to use OpenGL.</p>
<p>Should you be interested in learning more about the language, we <em>highly</em> recommend reading “<em>The Rust Programming Language</em>”, a free book online that will easily help you understand Rust: <a href="https://doc.rust-lang.org/book/">https://doc.rust-lang.org/book/</a></p>
<p>Additionally, here are a few quick resources that could be useful.</p>
<ul class="incremental">
<li><strong>Rust by Example:</strong><br />
<a href="https://doc.rust-lang.org/stable/rust-by-example/index.html" class="uri">https://doc.rust-lang.org/stable/rust-by-example/index.html</a></li>
<li><strong>Rust in easy English:</strong><br />
<a href="https://github.com/Dhghomon/easy_rust/blob/master/README.md#writing-rust-in-easy-english" class="uri">https://github.com/Dhghomon/easy_rust/blob/master/README.md#writing-rust-in-easy-english</a></li>
<li><strong>Learn Rust in Y Minutes:</strong><br />
<a href="https://learnxinyminutes.com/docs/rust/" class="uri">https://learnxinyminutes.com/docs/rust/</a></li>
<li><strong>Rust cheat sheet:</strong><br />
<a href="https://cheats.rs/" class="uri">https://cheats.rs/</a><br />
<em>(Bear in mind that this sheet is designed for people that already know the language, or at least are familiar with its concepts.)</em></li>
</ul>
<h1 id="getting-started">Getting Started</h1>
<p>First, go to one of these links to get the Rust compiler up and running:</p>
<blockquote>
<p><a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a><br />
<a href="https://doc.rust-lang.org/book/ch01-01-installation.html">https://doc.rust-lang.org/book/ch01-01-installation.html</a></p>
</blockquote>
<p>On Windows, when installing the Build Tools for Visual Studio 2019, select:</p>
<blockquote>
<p><img src="img/shot.png" style="width:24em" /></p>
</blockquote>
<p>An often preferred code editor for writing Rust is VSCode, short for Visual Studio Code (<a href="https://code.visualstudio.com/" class="uri">https://code.visualstudio.com/</a>). With it you should install and use the official Rust extension to get proper syntax highlighting and error squiggles (i.e. linting). For GLSL syntax highlighting we recommend installing the “Shader languages support” extension.</p>
<p>Optionally you can install the “Code Runner” extension, and set up the custom command to be “<code>cargo run</code>” for the project. To get to the settings page in VSCode, use the hotkey <span class="smallcaps">Ctrl+Shift+P</span>, then type “settings” into the resulting text box and hit <span class="smallcaps">Enter</span>. VSCode supports searching in the settings ui, making the rest pretty straight forward: type “custom command” to find the related setting.</p>
<p>Alternatives to VSCode include:</p>
<ul class="incremental">
<li>Atom with the <code>ide-rust</code> and <code>language-glsl</code> plugins</li>
<li>IntelliJ IDEA with <code>IntelliJ Rust</code> and <code>GLSL Support</code>.</li>
<li>Eclipse with <code>RustDT</code> and <code>Eclipse Shaders</code>.</li>
<li>Vim with the official <code>rust.vim</code> plugin, and your choice of <code>glsl</code> highlightning</li>
<li>Emacs with <code>rust-mode</code> and <code>glsl-mode</code></li>
<li>Kate with <code>rust-racer</code>.</li>
</ul>
<p>Your mileage may vary.</p>
<p>If you have any problems getting up and running, feel free to show up to a lab session or contacting us by email.</p>
<h1 id="variables-and-types">Variables and Types</h1>
<h2 id="declaring-variables">Declaring variables</h2>
<p>We use the <code class="sourceCode rust"><span class="kw">let</span></code> keyword to declare the existence of a new variable:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">6</span><span class="op">;</span>      <span class="co">// the type is inferred from the value</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y<span class="op">:</span> <span class="dt">i16</span> <span class="op">=</span> <span class="dv">7</span><span class="op">;</span> <span class="co">// here we explicitly specify a type</span></span></code></pre></div>
<h2 id="printing-values">Printing values</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;Hello, world!&quot;</span>)<span class="op">;</span> <span class="co">// Exclamation mark is necessary, as println is a macro</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;Hello, {}&quot;</span><span class="op">,</span> x)<span class="op">;</span> <span class="co">// Hello, 6</span></span></code></pre></div>
<h2 id="mutability">Mutability</h2>
<p>Variables are <em>immutable</em> by default, meaning that they cannot be modified. If you want to modify them you need to declare them as <em>mutable</em>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">6</span><span class="op">;</span>     <span class="co">// immutable</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> y <span class="op">=</span> <span class="dv">6</span><span class="op">;</span> <span class="co">// mutable</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// &lt;- This is fine</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// &lt;- This will cause a compiler error</span></span></code></pre></div>
<h2 id="integers">Integers</h2>
<p>Integers (i.e. whole numbers) may include a <em>sign</em>, which determines whether they are negative or not. As such we have two different types of integers: <em>signed</em> and <em>unsigned</em> integers, listed in Table 1.</p>
<div id="tbl:integers">
<table>
<caption>Table 1: A list of signed and unsigned integer type names in Rust, with corresponding C++ type names. <em>(The C++ names are useful to know when reading the OpenGL documentation.)</em></caption>
<thead>
<tr class="header">
<th>Signed</th>
<th>Unsigned</th>
<th>C++ name</th>
<th style="text-align: center;"># of bits</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="sourceCode rust"><span class="dt">i8</span></code></td>
<td><code class="sourceCode rust"><span class="dt">u8</span></code></td>
<td>(<code class="sourceCode cpp"><span class="dt">unsigned</span></code>) <code class="sourceCode cpp"><span class="dt">char</span></code></td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td><code class="sourceCode rust"><span class="dt">i16</span></code></td>
<td><code class="sourceCode rust"><span class="dt">u16</span></code></td>
<td>(<code class="sourceCode cpp"><span class="dt">unsigned</span></code>) <code class="sourceCode cpp"><span class="dt">short</span></code></td>
<td style="text-align: center;">16</td>
</tr>
<tr class="odd">
<td><code class="sourceCode rust"><span class="dt">i32</span></code></td>
<td><code class="sourceCode rust"><span class="dt">u32</span></code></td>
<td>(<code class="sourceCode cpp"><span class="dt">unsigned</span></code>) <code class="sourceCode cpp"><span class="dt">int</span></code></td>
<td style="text-align: center;">32</td>
</tr>
<tr class="even">
<td><code class="sourceCode rust"><span class="dt">i64</span></code></td>
<td><code class="sourceCode rust"><span class="dt">u64</span></code></td>
<td>(<code class="sourceCode cpp"><span class="dt">unsigned</span></code>) <code class="sourceCode cpp"><span class="dt">long</span> <span class="dt">long</span></code></td>
<td style="text-align: center;">64</td>
</tr>
<tr class="odd">
<td><code class="sourceCode rust"><span class="dt">i128</span></code></td>
<td><code class="sourceCode rust"><span class="dt">u128</span></code></td>
<td><em>none</em></td>
<td style="text-align: center;">128</td>
</tr>
<tr class="even">
<td><code class="sourceCode rust"><span class="dt">isize</span></code></td>
<td><code class="sourceCode rust"><span class="dt">usize</span></code></td>
<td><code class="sourceCode cpp"><span class="dt">size_t</span></code></td>
<td style="text-align: center;">depends</td>
</tr>
</tbody>
</table>
</div>
<p><code class="sourceCode rust"><span class="dt">isize</span></code> and <code class="sourceCode rust"><span class="dt">usize</span></code> varies with the machine architeture, but is at least large enough to reference the whole memory address space. As such it is used when indexing into lists and arrays.</p>
<p>You declare the <em>type</em> of a variable by:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a<span class="op">:</span> <span class="dt">i8</span> <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> <span class="co">// signed, 8 bit</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b<span class="op">:</span> <span class="dt">u8</span> <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> <span class="co">// unsigned, 8 bit</span></span></code></pre></div>
<p>Alternatively you can let the Rust compiler <em>infer</em> the type of the variable from the assigned value. Integer literals default to <code class="sourceCode rust"><span class="dt">i32</span></code>, but this can be changed with a suffix:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>   <span class="co">// signed, 32 bit</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b <span class="op">=</span> <span class="dv">10i8</span><span class="op">;</span> <span class="co">// signed,  8 bit</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c <span class="op">=</span> <span class="dv">10u8</span><span class="op">;</span> <span class="co">// unsigned, 8 bit</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> d<span class="op">;</span>        <span class="co">// ?!?</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="dv">10u8</span><span class="op">;</span>     <span class="co">// Aha! unsigned, 8 bit !</span></span></code></pre></div>
<p>Type declarations are thus usually not needed, since the defaults <code class="sourceCode rust"><span class="dt">i32</span></code> and <code class="sourceCode rust"><span class="dt">f64</span></code> for integer and floating point literals usually are sufficient.</p>
<h2 id="floating-point-numbers">Floating Point numbers</h2>
<p>Non-whole numbers are usually represented with floating point representations: floats! In Rust, <code class="sourceCode rust"><span class="dt">f64</span></code> is the default floating point type, and is known in C++ land as a <code class="sourceCode cpp"><span class="dt">double</span></code>. <code class="sourceCode rust"><span class="dt">f32</span></code> is the 32-bits wide variant, and is known as a <code class="sourceCode cpp"><span class="dt">float</span></code> in C++.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> x <span class="op">=</span> <span class="dv">75.0</span><span class="op">;</span>      <span class="co">// This is inferred as a f64, the default</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y<span class="op">:</span> <span class="dt">f32</span> <span class="op">=</span> <span class="dv">75.0</span><span class="op">;</span> <span class="co">// This is a f32 declaration. The literal gets converted.</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> z <span class="op">=</span> <span class="dv">75.0f32</span><span class="op">;</span>   <span class="co">// This literal is a f32, and z is inferred as such.</span></span></code></pre></div>
<p>You will probably have to specify that you want 32-bit floating point values when using OpenGL.</p>
<h2 id="bool">Bool</h2>
<p>In Rust we represent boolean values as <code class="sourceCode rust"><span class="dt">bool</span></code>. Its members are <code class="sourceCode rust"><span class="cn">true</span></code> and <code class="sourceCode rust"><span class="cn">false</span></code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> a<span class="op">:</span> <span class="dt">bool</span> <span class="op">=</span> <span class="dv">5</span> <span class="op">&gt;</span> <span class="dv">3</span><span class="op">;</span>  <span class="co">// true</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> b<span class="op">:</span> <span class="dt">bool</span> <span class="op">=</span> <span class="dv">5</span> <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span>  <span class="co">// false</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> c<span class="op">:</span> <span class="dt">bool</span> <span class="op">=</span> a <span class="op">&amp;&amp;</span> b<span class="op">;</span> <span class="co">// false</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="pp">assert!</span>(a <span class="op">||</span> b)<span class="op">;</span>      <span class="co">// true (a run-time check, will panic/crash if false)</span></span></code></pre></div>
<h2 id="tuples">Tuples</h2>
<p>Tuples are simple structures are commonly used to store multiple different types of values in a fixed-size block. Useful for stuff like coordinates!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> foobar<span class="op">:</span> (<span class="dt">i32</span><span class="op">,</span> <span class="dt">i32</span><span class="op">,</span> <span class="dt">f32</span>) <span class="op">=</span> (<span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">1.2</span>)<span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> point_2d<span class="op">:</span> (<span class="dt">f32</span><span class="op">,</span> <span class="dt">f32</span>) <span class="op">=</span> (<span class="dv">1.0</span><span class="op">,</span> <span class="dv">3.4</span>)<span class="op">;</span></span></code></pre></div>
<p>You can <em>unpack</em> a tuple, assigning their inner values to variables:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> (a<span class="op">,</span> b<span class="op">,</span> c) <span class="op">=</span> (<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>)<span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">assert!</span>(a <span class="op">==</span> <span class="dv">1</span>)<span class="op">;</span></span></code></pre></div>
<h2 id="arrays-and-vectors">Arrays and vectors</h2>
<p>To store a sequence of values of the same type, use either <em>arrays</em> or <em>vectors</em>. The size of <em>arrays</em> must be known at compile-time, and can therefore be stored on the program <em>stack</em>. <em>Vectors</em> may be dynamically sized and resized, and are as such stored in dynamic memory: the <em>heap</em>.</p>
<h3 class="unlisted unnumbered" id="arrays">Arrays</h3>
<p>Storing arrays of numbers on the stack can be done like so:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers <span class="op">=</span> [  <span class="co">// array type and size inferred</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span>  <span class="co">// trailing comma is permitted ;-)</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>]<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co">// or</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> f32_numbers<span class="op">:</span> [<span class="dt">f32</span><span class="op">;</span> <span class="dv">5</span>] <span class="op">=</span> [ <span class="co">// explicit type and size</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">4.0</span><span class="op">,</span> <span class="dv">5.0</span><span class="op">,</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>]<span class="op">;</span></span></code></pre></div>
<h3 class="unlisted unnumbered" id="vectors">Vectors</h3>
<p>You should for the most part <strong>use vectors instead than arrays</strong> for these assignments.<br />
Storing a sequence of numbers on the heap is done like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers_vec             <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>]<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers_vec_2<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">f32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span>new()<span class="op">;</span>          <span class="co">// `::new` infers type from declaration</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers_vec_3           <span class="op">=</span> <span class="dt">Vec</span><span class="pp">::</span><span class="op">&lt;</span><span class="dt">f32</span><span class="op">&gt;</span><span class="pp">::</span>new()<span class="op">;</span>   <span class="co">// type passed into `::new` explicitly</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers_vec_4<span class="op">:</span> <span class="dt">Vec</span><span class="op">&lt;</span><span class="dt">f32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span>]<span class="op">;</span> <span class="co">// The literals would alone result</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>                                                   <span class="co">// in a Vec&lt;f64&gt;, but the declaration</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>                                                   <span class="co">// converted it.</span></span></code></pre></div>
<p>Storing numbers on the heap allows you to append new elements:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>numbers_vec<span class="op">.</span>push(<span class="dv">6</span>)<span class="op">;</span> <span class="co">// A vector must be declared as `mut` if you</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>                     <span class="co">// want to push new values to it!</span></span></code></pre></div>
<h2 id="iterating-over-arrays-and-vectors">Iterating over arrays and vectors</h2>
<p>The easiest way to iterate over a vector is with a <code class="sourceCode rust"><span class="cf">for</span></code> loop:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> numbers <span class="op">=</span> <span class="pp">vec!</span>[<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span>]<span class="op">:</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> number <span class="kw">in</span> numbers <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;number is {}&quot;</span><span class="op">,</span> number)<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="scoping-borrowing-and-ownership">Scoping, Borrowing and Ownership</h2>
<p>Although we provide a brief overview of “ownership” here, we recommend you read the following to get a deeper understanding: <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html" class="uri">https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html</a></p>
<p>Ownership is one of the things that makes Rust unique, and is the feature that allows the language to not have to be <em>garbage collected</em> during runtime while still retaining memory safety guarantees.</p>
<p>If you want to “move”<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> a variable somewhere without losing ownership, you can create a <em>borrow</em>. <strong>The key takeaway is:</strong> a variable is removed from memory when it goes out of <em>scope</em>, but not when a borrow goes out of scope.</p>
<p>A <em>scope</em> is defined by the <code class="sourceCode rust"><span class="op">{}</span></code> brackets. Any variable defined with <code class="sourceCode rust"><span class="kw">let</span></code> inside of a scope gets deleted once you leave the scope.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="op">{</span> <span class="co">// this is the beginning of a *scope*</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> b <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> <span class="co">// declaration of `b`</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// `b` goes out of scope here</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> c <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;Hello&quot;</span>)<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> g <span class="op">=</span> <span class="dt">String</span><span class="pp">::</span>from(<span class="st">&quot;World&quot;</span>)<span class="op">;</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> n <span class="op">=</span> <span class="dv">13</span><span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">{</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> borrowed_c <span class="op">=</span> <span class="op">&amp;</span>c<span class="op">;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> copied_n   <span class="op">=</span> n<span class="op">;</span>  <span class="co">// copied, since `i32` implements `Copy`</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> moved_g    <span class="op">=</span> g<span class="op">;</span>  <span class="co">// moved,  since `String` does not implement `Copy`</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="co">// `borrowed_c` goes out of scope, c is untouched</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>      <span class="co">// `copied_n`   goes out of scope, n is still fine</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>      <span class="co">// `moved_g`    goes out of scope, g no longer valid</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;c: {}&quot;</span><span class="op">,</span> c)<span class="op">;</span> <span class="co">// no problem</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;n: {}&quot;</span><span class="op">,</span> n)<span class="op">;</span> <span class="co">// Also fine</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    <span class="pp">println!</span>(<span class="st">&quot;g: {}&quot;</span><span class="op">,</span> g)<span class="op">;</span> <span class="co">// ERROR!</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="co">// c,g,n goes out of scope</span></span></code></pre></div>
<h1 id="functions">Functions</h1>
<p>Calling a function will very often require you to borrow the arguments with <code>&amp;</code> instead of passing them in directly:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rotate_amount<span class="op">:</span> <span class="dt">f32</span> <span class="op">=</span> <span class="dv">3.0</span> <span class="op">/</span> <span class="dv">4.0</span> <span class="op">*</span> <span class="pp">glm::</span>pi<span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> y_axis <span class="op">=</span> <span class="pp">glm::</span>vec3(<span class="dv">0.0</span><span class="op">,</span> <span class="dv">1.0</span><span class="op">,</span> <span class="dv">0.0</span>)<span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rot <span class="op">=</span> <span class="pp">glm::</span>rotation(rotate_amount<span class="op">,</span> <span class="op">&amp;</span>y_axis)<span class="op">;</span></span></code></pre></div>
<p>Simple types such as numbers can be used directly, but vectors has to be borrowed. If you get errors while calling functions, inserting a <code class="sourceCode rust"><span class="op">&amp;</span></code> usually fixes it.</p>
<p>Some functions ask you for a <em>mutable reference</em> to some value. As such it is not enough to simply make the variable itself mutable in this situation, you actually need to explicitly say that a reference to that variable permits mutation. The way to do that is:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> variable <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>some_function(<span class="op">&amp;</span><span class="kw">mut</span> variable)<span class="op">;</span></span></code></pre></div>
<h2 id="defining-functions">Defining functions</h2>
<p>A function signature in Rust looks like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> function_name(argument_1<span class="op">:</span> <span class="dt">f32</span><span class="op">,</span> argument_2<span class="op">:</span> <span class="dt">i8</span>) <span class="op">-&gt;</span> <span class="dt">u8</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Function body                                  ^ return type</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A function with no return value looks like this:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> void_func() <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Function body</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>A function will return the final expression in its body by default, which lets your functions look a bit less cluttered</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> double_value(value<span class="op">:</span> <span class="dt">f32</span>) <span class="op">-&gt;</span> <span class="dt">f32</span> <span class="op">{</span> value <span class="op">*</span> <span class="dv">2</span> <span class="op">}</span></span></code></pre></div>
<p>Semicolons turn expressions into void statements:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> no_return_value(value<span class="op">:</span> <span class="dt">f32</span>) <span class="op">{</span> value <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<p>The <code class="sourceCode rust"><span class="cf">return</span></code> statement still works as expected:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> double_value(value<span class="op">:</span> <span class="dt">f32</span>) <span class="op">-&gt;</span> <span class="dt">f32</span> <span class="op">{</span> <span class="cf">return</span> value <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span></code></pre></div>
<h2 id="generic-functions">Generic functions</h2>
<p>Calling a generic function with a <em>type parameter</em> requires you to use the “turbofish” operator (<code>::&lt;&gt;</code>) to specify the type:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> byte_size_of_f32 <span class="op">=</span> <span class="pp">mem::size_of::</span><span class="op">&lt;</span><span class="dt">f32</span><span class="op">&gt;</span>()<span class="op">;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="co">//                                      ^ type argument</span></span></code></pre></div>
<p>If the generic function uses the generic type (<code>T</code>) in one of its input parameters:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> double<span class="op">&lt;</span>T<span class="op">&gt;</span>(input<span class="op">:</span> T) <span class="op">-&gt;</span> T<span class="op">;</span></span></code></pre></div>
<p>, then it is able to <em>infer</em> <code>T</code> from the input:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;I doubled the input&quot;</span><span class="op">,</span> double(<span class="dv">4</span>))<span class="op">;</span> <span class="co">// no turbofish!</span></span></code></pre></div>
<h1 id="interfacing-with-opengl">Interfacing with OpenGL</h1>
<p>OpenGL was designed for C and C++. We use simple bindings to the C interface in Rust.</p>
<h2 id="unsafe">Unsafe</h2>
<p>Some things, such as dereferencing<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> a raw pointer, or calling a function from outside of Rust is always illegal in “safe” Rust. There is simply no way for the compiler to guarantee that nothing will go wrong (read; segfault) when doing it, so you must tell the compiler that you know what you’re doing in order to be allowed such power.</p>
<p>C and C++ on the other hand always operate in such an unsafe manner, and the OpenGL interface was designed assuming so.</p>
<p>We signal to the compiler that we’re about to do something dangerous by using the <code class="sourceCode rust"><span class="kw">unsafe</span></code> keyword:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Let&#39;s dereference null! :D</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> p<span class="op">:</span> <span class="op">*</span><span class="kw">const</span> <span class="dt">i32</span> <span class="op">=</span> <span class="pp">std::ptr::</span>null()<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> extremely_dangerous <span class="op">=</span> <span class="op">*</span>p<span class="op">;</span> <span class="co">// Hard crash!</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>When you need to return a value from an unsafe block, there are a couple of different ways to go about doing so. The first is to declare the variable outside of the block without assigning it a value, and then assigning it inside of the unsafe block.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> value<span class="op">;</span> <span class="co">// no type annotation needed</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>    value <span class="op">=</span> unsafe_operation()<span class="op">;</span> <span class="co">// type inferred from here</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The second option is to return a value from the unsafe block, as Rust supports using blocks on the right hand side of an assignment:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> value <span class="op">=</span> <span class="kw">unsafe</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    unsafe_operation() <span class="co">// notice the lack of a semicolon: an implicit return</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="op">};</span> <span class="co">// This semicolon terminates the `let` statement</span></span></code></pre></div>
<p>We can also mark whole functions as <code class="sourceCode rust"><span class="kw">unsafe</span></code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="kw">fn</span> my_function() <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// something dangerous</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Usage of the <code class="sourceCode rust"><span class="kw">unsafe</span></code> keyword should be minimized as much as possible in general, making it easier to locate mistakes.</p>
<h2 id="the-opengl-c-bindings">The OpenGL C bindings</h2>
<p>Calling OpenGL functions is our way of communicating with the GPU. Every single OpenGL function call is <strong>unsafe</strong>, as they are simply raw bindings to C functions. This means that <em>all</em> calls to OpenGL functions must be within an <code class="sourceCode rust"><span class="kw">unsafe</span></code> block or a function (<code class="sourceCode rust"><span class="kw">fn</span></code>) marked <code class="sourceCode rust"><span class="kw">unsafe</span></code>.</p>
<p>While OpenGL functions names in C++ will have <code>gl</code> as a <em>prefix</em>, in Rust they are instead <em>namespaced</em> under <code class="sourceCode rust">gl</code>. In other words: <code class="sourceCode rust"><span class="pp">gl::</span>SomeFunction</code>. This also applies to the “<code>GL_</code>” part of OpenGL enumerators. So if you find a function you want to use online, you’ll have to <em>translate</em> it a little to be able to use it in Rust:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>glSomeFunction<span class="op">(</span>GL_SOME_VALUE<span class="op">);</span></span></code></pre></div>
<p>, in C or C++ will in Rust become:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">unsafe</span> <span class="op">{</span> <span class="pp">gl::</span>SomeFunction(<span class="pp">gl::</span>SOME_VALUE) <span class="op">};</span></span></code></pre></div>
<h2 id="pointers">Pointers</h2>
<p>Pointers are commonly used in C and C++, and simply point to some address in memory. They are quite powerful, but commonly regarded as unsafe. Pointers may include the <em>type</em> of the data it is pointing at. In C and C++, <code class="sourceCode cpp"><span class="op">*</span><span class="dt">int</span></code> is read as “int pointer”, and <code class="sourceCode cpp"><span class="op">*</span><span class="dt">void</span></code> is read as “void pointer”<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. In Rust they equate to <code class="sourceCode rust"><span class="op">*</span><span class="kw">mut</span> <span class="dt">i32</span></code> and <code class="sourceCode rust"><span class="op">*</span><span class="kw">mut</span> <span class="dt">c_void</span></code> respectably.</p>
<p>Sometimes when the Hitchhiker’s guide to OpenGL suggests you use <code class="sourceCode rust"><span class="dv">0</span></code> as the input value, Rust will complain that it expects a pointer. While C++ is perfectly happy to implicitly coerce <code class="sourceCode rust"><span class="dv">0</span></code> into a pointer for you, Rust requires you to be a bit more explicit about it. You can placate Rust by either using <code class="sourceCode rust"><span class="pp">ptr::</span>null()</code> or <code class="sourceCode rust"><span class="dv">0</span> <span class="kw">as</span> <span class="op">*</span><span class="kw">const</span> <span class="dt">c_void</span></code> in these situations.</p>
<p>One way OpenGL often returns values is by modifying variables provided as pointers. This is because most calls to OpenGL support reading and returning an arbitrary amount of values, and using pointers used to be a simple (in the days of olde) work-around for the limitation of functions returning just a single item.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> result<span class="op">:</span> <span class="dt">u32</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>                 <span class="co">// initialized to 0, doesn&#39;t matter really.</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>                                         <span class="co">// What IS important is that it reserves</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>                                         <span class="co">// 4 bytes in memory</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="pp">gl::</span>SomeAction(<span class="op">&amp;</span><span class="kw">mut</span> result <span class="kw">as</span> <span class="op">*</span><span class="kw">mut</span> <span class="dt">u32</span>)<span class="op">;</span> <span class="co">// We provide a mutable pointer to `result`.</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>                                         <span class="co">// The `as *mut u32` part is usually optional.</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="pp">println!</span>(<span class="st">&quot;Result is: {}&quot;</span><span class="op">,</span> result)<span class="op">;</span>       <span class="co">// the function modified `result` as a</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a>                                         <span class="co">// side-effect by directly writing to</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>                                         <span class="co">// where in memory it is located. As a</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>                                         <span class="co">// result, this now prints something</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>                                         <span class="co">// else than 0</span></span></code></pre></div>
<blockquote>
<p><strong>The following information is only needed from assignment 2 and onward.</strong></p>
</blockquote>
<h1 id="glm---opengl-mathematics">GLM - OpenGL Mathematics</h1>
<p>The Hitchhikers guide to OpenGL details the data types found in GLSL – the OpenGL Shader Language. To replicate the data types in GLSL and their supported operations on the CPU, some clever guys created the GLM library. We specifically will be using a variant known as <code>nalgebra-glm</code>.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<h2 id="vectors-and-swizzling">Vectors and swizzling</h2>
<p>The type <code class="sourceCode rust"><span class="pp">glm::</span>Vec3</code> represents a column vector with 3 elements. Similarly, we have <code class="sourceCode rust"><span class="pp">glm::</span>Vec2</code> and <code class="sourceCode rust"><span class="pp">glm::</span>Vec4</code>. The following three vectors are equivalent:</p>
<p><span class="math display">$$
    p={\begin{bmatrix}{1}\\ {2}\\ {3}\end{bmatrix}}
$$</span></p>
<div class="sourceCode" id="cb32"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> p <span class="op">=</span> <span class="pp">glm::Vec3::</span>new(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span>)<span class="op">;</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> p <span class="op">=</span> <span class="pp">glm::</span>vec3(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span>)<span class="op">;</span></span></code></pre></div>
<p><em>( The lowercase <code>vec3</code> function is basically just an alias to <code class="sourceCode rust"><span class="pp">Vec3::</span>new</code> )</em></p>
<p>To access the scalar elements of a vector you can address them using the <code>[]</code> operator, or referring to them using the common component names assigned by GLM and GLSL:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> v <span class="op">=</span> <span class="pp">glm::</span>vec4(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">4.0</span>)<span class="op">;</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>v[<span class="dv">0</span>]  <span class="op">==</span>  v<span class="op">.</span>x  <span class="op">==</span>  v<span class="op">.</span>r   <span class="co">// these have the value 1.0</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>v[<span class="dv">1</span>]  <span class="op">==</span>  v<span class="op">.</span>y  <span class="op">==</span>  v<span class="op">.</span>g   <span class="co">// these have the value 2.0</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>v[<span class="dv">2</span>]  <span class="op">==</span>  v<span class="op">.</span>z  <span class="op">==</span>  v<span class="op">.</span>b   <span class="co">// these have the value 3.0</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>v[<span class="dv">3</span>]  <span class="op">==</span>  v<span class="op">.</span>w  <span class="op">==</span>  v<span class="op">.</span>a   <span class="co">// these have the value 4.0</span></span></code></pre></div>
<p>This notation follows from how a <code>Vec4</code> can be used to represent both homogeneous coordinates (XYZW) and colors (RGBA).</p>
<p>From such a vector, you can extract the components in any order you’d like using <strong>swizzling</strong>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> v <span class="op">=</span> <span class="pp">glm::</span>vec4(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span><span class="op">,</span> <span class="dv">4.0</span>)<span class="op">;</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>xyz()  <span class="op">==</span>  <span class="pp">glm::</span>vec3(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span>)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>zyx()  <span class="op">==</span>  <span class="pp">glm::</span>vec3(<span class="dv">3.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">1.0</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>v<span class="op">.</span>xx()   <span class="op">==</span>  <span class="pp">glm::</span>vec2(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">1.0</span>)</span></code></pre></div>
<h2 id="matrices">Matrices</h2>
<p>The type <code class="sourceCode rust"><span class="pp">glm::</span>Mat4</code> (an alias to <code class="sourceCode rust"><span class="pp">glm::</span>Mat4x4</code>) represents a <span class="math inline">4 × 4</span> matrix containing 16 elements. Similarly, we have a <code class="sourceCode rust"><span class="pp">glm::</span>Mat3</code>. These following three matrices are equivalent:</p>
<p><span class="math display">$$
    M = {\begin{bmatrix}{a}&amp;{b}&amp;{c}\\ {d}&amp;{e}&amp;{f}\\ {g}&amp;{h}&amp;{i}\end{bmatrix}}
$$</span></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> M <span class="op">=</span> <span class="pp">glm::Mat3::</span>new(</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    a<span class="op">,</span>  d<span class="op">,</span>  g<span class="op">,</span>   <span class="co">// 1st column</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    b<span class="op">,</span>  e<span class="op">,</span>  h<span class="op">,</span>   <span class="co">// 2nd column</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    c<span class="op">,</span>  f<span class="op">,</span>  i<span class="op">,</span>   <span class="co">// 3rd column</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> M <span class="op">=</span> <span class="pp">glm::</span>mat3(</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    a<span class="op">,</span>  d<span class="op">,</span>  g<span class="op">,</span>   <span class="co">// 1st column</span></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    b<span class="op">,</span>  e<span class="op">,</span>  h<span class="op">,</span>   <span class="co">// 2nd column</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    c<span class="op">,</span>  f<span class="op">,</span>  i<span class="op">,</span>   <span class="co">// 3rd column</span></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>)<span class="op">;</span></span></code></pre></div>
<p><em>( The lowercase <code>mat3</code> function is basically just an alias to <code class="sourceCode rust"><span class="pp">Mat3::</span>new</code> )</em></p>
<p>Notice how the values are mirrored/flipped along the diagonal? This is because matrices in GLM and GLSL are <strong>column major</strong>.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> If you’re not familiar with the term, column major means that you first address the column, then the row.</p>
<p>As such, when addressing a single element in a matrix we have:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>M[(column<span class="op">,</span> row)]</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>M[(<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>)]  <span class="op">==</span>  d</span></code></pre></div>
<p>Notice how we use a <code class="sourceCode rust">(<span class="dt">usize</span><span class="op">,</span> <span class="dt">usize</span>)</code> tuple to index into the matrix with the <code>[]</code> operator.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<p>Luckily, flipping a matrix along the diagonal is a common operation known as <em>transposing</em> a matrix. The mathematical notation for matrix transposition is <span class="math inline"><em>M</em><sup><em>T</em></sup></span>. In GLM and GLSL, the function <code>transpose</code> implements this for us:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> M <span class="op">=</span> <span class="pp">glm::</span>transpose(<span class="pp">glm::</span>mat3(</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    a<span class="op">,</span>  b<span class="op">,</span>  c<span class="op">,</span>   <span class="co">// 1st row</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    d<span class="op">,</span>  e<span class="op">,</span>  f<span class="op">,</span>   <span class="co">// 2nd row</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    g<span class="op">,</span>  h<span class="op">,</span>  i<span class="op">,</span>   <span class="co">// 3rd row</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>))<span class="op">;</span></span></code></pre></div>
<h2 id="transformation-matrix-functions">Transformation matrix functions</h2>
<p>Here we showcase a few (simplified rust signatures of) GLM functions you’ll want to use to produce various transformation matrices, along with examples of how you’d use them.</p>
<blockquote>
<p><strong>Important:</strong> Notice that the functions return a <code class="sourceCode rust"><span class="pp">glm::</span>TMat<span class="op">&lt;</span>T<span class="op">,</span> D<span class="op">,</span> D<span class="op">&gt;</span></code>, the most generic form of a matrix. <code>T</code> is the type of the elements, and the <code>D</code>s are the two dimensions. <code class="sourceCode rust"><span class="pp">glm::</span>Mat4</code> is actually equal to <code class="sourceCode rust"><span class="pp">glm::</span>TMat4<span class="op">&lt;</span><span class="dt">f32</span><span class="op">&gt;</span></code>, which in turn is equal to <code class="sourceCode rust"><span class="pp">glm::</span>TMat<span class="op">&lt;</span><span class="dt">f32</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">4</span><span class="op">&gt;</span></code>.</p>
</blockquote>
<p>For this reason, every time you use any of the matrix generation functions from the GLM library, you should be specifying the <em>type</em> you want for the resulting variable, or at least make sure Rust is able to infer/deduce it based on how you use the returned value. Otherwise you might end up with a matrix of either the wrong size, or with <code class="sourceCode rust"><span class="dt">f64</span></code> elements! The examples below handles this properly.</p>
<h3 class="unlisted unnumbered" id="identity-matrix">Identity matrix</h3>
<p>To generate an identity matrix, we use the <code class="sourceCode rust"><span class="pp">glm::</span>identity</code> function, which looks like:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> glm::identity(scale<span class="op">:</span> <span class="op">&amp;</span><span class="pp">glm::</span>Vec3) <span class="op">-&gt;</span> <span class="pp">glm::</span>TMat<span class="op">&lt;</span>T<span class="op">,</span> D<span class="op">,</span> D<span class="op">&gt;;</span></span></code></pre></div>
<p>Example usage:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> identity<span class="op">:</span> <span class="pp">glm::</span>Mat4 <span class="op">=</span> <span class="pp">glm::</span>identity()<span class="op">;</span></span></code></pre></div>
<h3 class="unlisted unnumbered" id="translation-matrix">Translation matrix</h3>
<p>To generate a translation matrix, we use the <code class="sourceCode rust"><span class="pp">glm::</span>translation</code> function, which looks like:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> glm::translation(direction<span class="op">:</span> <span class="op">&amp;</span><span class="pp">glm::</span>Vec3) <span class="op">-&gt;</span> <span class="pp">glm::</span>TMat4<span class="op">&lt;</span>T<span class="op">&gt;;</span></span></code></pre></div>
<p>To generate a <span class="math inline">4 × 4</span> matrix, that translates by <span class="math inline">[1,2,3]<sup><em>T</em></sup></span>:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> translation<span class="op">:</span> <span class="pp">glm::</span>Mat4 <span class="op">=</span> <span class="pp">glm::</span>translation(<span class="op">&amp;</span><span class="pp">glm::</span>vec3(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">2.0</span><span class="op">,</span> <span class="dv">3.0</span>))<span class="op">;</span></span></code></pre></div>
<h3 class="unlisted unnumbered" id="scaling-matrix">Scaling matrix</h3>
<p>To generate a scaling matrix, we use the <code class="sourceCode rust"><span class="pp">glm::</span>scaling</code> function, which looks like:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> glm::scaling(scale<span class="op">:</span> <span class="op">&amp;</span><span class="pp">glm::</span>Vec3) <span class="op">-&gt;</span> <span class="pp">glm::</span>TMat4<span class="op">&lt;</span>T<span class="op">&gt;;</span></span></code></pre></div>
<p>To make a <span class="math inline">4 × 4</span> matrix that scales the input with coefficients <span class="math inline">[<em>s</em><sub><em>x</em></sub>,<em>s</em><sub><em>y</em></sub>,<em>s</em><sub><em>z</em></sub>]<sup><em>T</em></sup></span>:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> scaling<span class="op">:</span> <span class="pp">glm::</span>Mat4 <span class="op">=</span> <span class="pp">glm::</span>scaling(<span class="op">&amp;</span><span class="pp">glm::</span>vec3(sx<span class="op">,</span> sy<span class="op">,</span> sz))<span class="op">;</span></span></code></pre></div>
<h3 class="unlisted unnumbered" id="rotation-matrices">Rotation matrices</h3>
<p>To generate a rotation matrix, we use the <code class="sourceCode rust"><span class="pp">glm::</span>rotation</code> function, which looks like:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">fn</span> glm::rotation(angle<span class="op">:</span> <span class="dt">f32</span><span class="op">,</span> axis<span class="op">:</span> <span class="op">&amp;</span><span class="pp">glm::</span>Vec3) <span class="op">-&gt;</span> <span class="pp">glm::</span>TMat4<span class="op">&lt;</span>T<span class="op">&gt;;</span></span></code></pre></div>
<p>It takes in an <code>angle</code> measured in radians, and an <code>axis</code> which is the (unit) vector to rotate around.</p>
<p>To rotate <span class="math inline">45<sup>∘</sup></span> around the X axis:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rotation<span class="op">:</span> <span class="pp">glm::</span>Mat4 <span class="op">=</span> <span class="pp">glm::</span>rotation(<span class="dv">45.0f32</span><span class="op">.</span>to_radians()<span class="op">,</span> <span class="op">&amp;</span><span class="pp">glm::</span>vec3(<span class="dv">1.0</span><span class="op">,</span> <span class="dv">0.0</span><span class="op">,</span> <span class="dv">0.0</span>))<span class="op">;</span></span></code></pre></div>
<h2 id="composing-transformation-matrices">Composing transformation matrices</h2>
<p>In computer graphics it is customary to multiply transformations on the right hand side of column vectors, and GLM and OpenGL was designed with this in mind. As such we encourage you to structure your transformations something like this:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode rust"><code class="sourceCode rust"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">mut</span> trans<span class="op">:</span> <span class="pp">glm::</span>Mat4 <span class="op">=</span> <span class="pp">glm::</span>identity()<span class="op">;</span>  <span class="co">// begin with an empty transformation</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>trans <span class="op">=</span> <span class="pp">glm::</span>rotation(angle<span class="op">,</span> <span class="op">&amp;</span>axis)              <span class="op">*</span> trans<span class="op">;</span> <span class="co">// apply a rotation</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>trans <span class="op">=</span> <span class="pp">glm::</span>scaling(<span class="op">&amp;</span><span class="pp">glm::</span>veg3(sx<span class="op">,</span> sy<span class="op">,</span> sz))     <span class="op">*</span> trans<span class="op">;</span> <span class="co">// then apply some scaling</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>trans <span class="op">=</span> <span class="pp">glm::</span>translation(<span class="op">&amp;</span><span class="pp">glm::</span>veg3(tx<span class="op">,</span> ty<span class="op">,</span> tz)) <span class="op">*</span> trans<span class="op">;</span> <span class="co">// followed by a translation</span></span></code></pre></div>
<p>Using this structure, you can read the transformations applied ordered downward. It also enables you to quickly enable/disable transformations by commenting them, and reorder them by just moving whole lines. Most code editors allows you to move the current line with <span class="smallcaps">ALT+Up</span> and <span class="smallcaps">ALT+Down</span>.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Moving ownership is only a problem for “complicated” objects and data – the kind of values you can’t store on the stack. The specific reason why is that most builtin <em>“simple”</em> types implement the <code class="sourceCode rust"><span class="bu">Copy</span></code> Trait by default, which means they instead get copied when they are attempted to be moved. You can read more about Traits in the Rust book.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>“<em>Dereferencing</em>” a pointer means accessing the place in memory a pointer points at.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>“Void” means missing. “Void functions” return nothing. “Void pointers” may point at <em>anything</em>.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://docs.rs/nalgebra-glm/0.15.0/nalgebra_glm/" class="uri">https://docs.rs/nalgebra-glm/0.15.0/nalgebra_glm/</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="https://thebookofshaders.com/glossary/?search=mat4" class="uri">https://thebookofshaders.com/glossary/?search=mat4</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>For those interested, this is implemented here: <a href="https://docs.rs/nalgebra/0.29.0/nalgebra/base/struct.Matrix.html#impl-Index%3C(usize%2C%20usize)%3E" class="uri">https://docs.rs/nalgebra/0.29.0/nalgebra/base/struct.Matrix.html#impl-Index%3C(usize%2C%20usize)%3E</a><a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
